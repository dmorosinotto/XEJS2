//Creo una IIFE function expression che viene eseguita immediatamente, e ritorna la funzione interna//che grazie allo scope ereditato cattura al suo interno l'array _days che resta accesibile anche dopo l'esecuzione della IIFE//così ottengo sia PRIVACY dell'array, ma NON PAGO l'inizializzazione ad ogni giro, l'array lo creo 1 volta sola!!!var weekday = (    function IIFE_nome_ininfluente(){      var _days = ['Lunedì','Martedì','Mercoledì','Giovedì','Venerdì','Sabato']; //E' PRIVATE								return function weekday_INTERNAL_with_closure_to_access_days(n) {              ///QUESTA FUNZIONE GRAZIE AL SUO SCOPE CATTURA IL VALORE DI _days //CLOSURE su array padre								if ((typeof n === 'number') && (n in _days)) {									return _days[n];								} else {									return "NON ESISTE " + n;								}	            };		}() //esecuzione immediata della funzione --> inizializza _days e ritorna funzione INTERNAL);test("STEP 2 - IIFE + CLOSURE");//STEP BY STEP/*var days = ['Lunedì','Martedì','Mercoledì','Giovedì','Venerdì','Sabato'];function weekday(n) {	if ((typeof n === 'number') && (n in days)) {		return days[n];	} else {		return "NON ESISTE " + n;	}	}test("STEP 0 - PROBLEMA GLOBAL POLLUTION");/*//SPOSTO ARRAY days all'interno della funzione ottengo PRIVACY//Però pago scotto di inizializzare array ogni volta che eseguo funzione!!!function weekday(n) {	var _days = ['Lunedì','Martedì','Mercoledì','Giovedì','Venerdì','Sabato']; //USO NOTAZIONE SOLO PER RICORDARMI CHE E' PRIVATE	if ((typeof n === 'number') && (n in _days)) {		return _days[n];	} else {		return "NON ESISTE " + n;	}	}test("STEP 1 - (Function Scope -> PRIVACY)");*///TESTfunction test(msg) {  console.warn(msg);  for (var i=0; i<7; i++) console.log( weekday(i) );  }